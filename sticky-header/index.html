<!Doctype html>
<html class="no-js" lang="ko">
<head>
  <meta charset="UTF-8">
  <!-- Always force latest IE rendering engine (even in interanet) 
  & Chrome Frame Remove this if you use the .htacces -->
  <meta http-equiv="X-UA-Compatibilty" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sticky header advanced</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/notosanskr.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xeicon@2.3.3/xeicon.min.css">
  <link rel="stylesheet" href="main.css">
</head>
<body>
  <header class="page-header">
    <nav class="navbar navbar-responsive navbar-expand-lg">
      <a href="./" class="navbar-brand">LOGO</a>
      <button class="navbar-toggler not-active" type="button">
        <span class="nav-toggler-bar"></span>
        <span class="nav-toggler-bar"></span>
        <span class="nav-toggler-bar"></span>
      </button>
      <div class="navbar-collapse">
        <ul class="navbar-nav">
          <li class="nav-item" data-navid="0"><a href="#" class="nav-link"><span>Menu01</span></a></li>
          <li class="nav-item" data-navid="1"><a href="#" class="nav-link"><span>Menu02</span></a></li>
          <li class="nav-item" data-navid="2"><a href="#" class="nav-link"><span>Menu03</span></a></li>
          <li class="nav-item" data-navid="3"><a href="#" class="nav-link"><span>Menu04</span></a></li>
        </ul>
      </div>
    </nav>
  </header>
  
  <div class="dummy container">
    <h2>Event handlers</h2>
    <p>Imagine an interface where the only way to find out whether a key on the keyboard is being pressed is to read the current state of that key. To be able to react to keypresses, you would have to constantly read the key’s state so that you’d catch it before it’s released again. It would be dangerous to perform other time-intensive computations since you might miss a keypress.</p>
    <p>Some primitive machines do handle input like that. A step up from this would be for the hardware or operating system to notice the keypress and put it in a queue. A program can then periodically check the queue for new events and react to what it finds there.</p>
    <p>Of course, it has to remember to look at the queue, and to do it often, because any time between the key being pressed and the program noticing the event will cause the software to feel unresponsive. This approach is called polling. Most programmers prefer to avoid it.</p>
    <p>A better mechanism is for the system to actively notify our code when an event occurs. Browsers do this by allowing us to register functions as handlers for specific events.</p>
    <br>
    <p>Imagine an interface where the only way to find out whether a key on the keyboard is being pressed is to read the current state of that key. To be able to react to keypresses, you would have to constantly read the key’s state so that you’d catch it before it’s released again. It would be dangerous to perform other time-intensive computations since you might miss a keypress.</p>
    <p>Some primitive machines do handle input like that. A step up from this would be for the hardware or operating system to notice the keypress and put it in a queue. A program can then periodically check the queue for new events and react to what it finds there.</p>
    <p>Of course, it has to remember to look at the queue, and to do it often, because any time between the key being pressed and the program noticing the event will cause the software to feel unresponsive. This approach is called polling. Most programmers prefer to avoid it.</p>
    <p>A better mechanism is for the system to actively notify our code when an event occurs. Browsers do this by allowing us to register functions as handlers for specific events.</p>
    <br>
    <p>Imagine an interface where the only way to find out whether a key on the keyboard is being pressed is to read the current state of that key. To be able to react to keypresses, you would have to constantly read the key’s state so that you’d catch it before it’s released again. It would be dangerous to perform other time-intensive computations since you might miss a keypress.</p>
    <p>Some primitive machines do handle input like that. A step up from this would be for the hardware or operating system to notice the keypress and put it in a queue. A program can then periodically check the queue for new events and react to what it finds there.</p>
    <p>Of course, it has to remember to look at the queue, and to do it often, because any time between the key being pressed and the program noticing the event will cause the software to feel unresponsive. This approach is called polling. Most programmers prefer to avoid it.</p>
    <p>A better mechanism is for the system to actively notify our code when an event occurs. Browsers do this by allowing us to register functions as handlers for specific events.</p>
    <br>
    <p>Imagine an interface where the only way to find out whether a key on the keyboard is being pressed is to read the current state of that key. To be able to react to keypresses, you would have to constantly read the key’s state so that you’d catch it before it’s released again. It would be dangerous to perform other time-intensive computations since you might miss a keypress.</p>
    <p>Some primitive machines do handle input like that. A step up from this would be for the hardware or operating system to notice the keypress and put it in a queue. A program can then periodically check the queue for new events and react to what it finds there.</p>
    <p>Of course, it has to remember to look at the queue, and to do it often, because any time between the key being pressed and the program noticing the event will cause the software to feel unresponsive. This approach is called polling. Most programmers prefer to avoid it.</p>
    <p>A better mechanism is for the system to actively notify our code when an event occurs. Browsers do this by allowing us to register functions as handlers for specific events.</p>
    <br>
    <a href="https://eloquentjavascript.net/15_event.html"><small>https://eloquentjavascript.net/15_event.html</small></a>
  </div>

  <script src="main.js"></script>
</body>
</html>